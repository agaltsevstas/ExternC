# extern "C"
extern "C" - директива, которая помогает загрузить функцию из языка Си в C++. Эта директика не существует для языка Си, но существует для языка C++, поэтому чтобы функция компилировалась сразу на 2 языках (например, общая библиотека): С и C++ нужно обернуть в директиву условной компиляции.
## C
В C НЕТ перегрузки функций, т.к. компилятор формирует промежуточные объектные файлы (.o)/(.obj) (в зависимости от комплиятора), в которых указаны ТОЛЬКО имена функций без ее типов аргументов, поэтому компоновщик видит ТОЛЬКО имя функции:
```
#ifdef __cplusplus
extern "C" // можно без скобок
{
     int Module(int number) // _Z6Module (_Z6 - метка функции + кол-во символов, Module - имя функции)
     {
         return number > 0 ? number : -number;
     }
}
#endif
```

## C++
В C++ ЕСТЬ перегрузка функций, поэтому компоновщик видит имя функции + тип переменной. Благодаря искажении имен (name mangling) происходит перегрузка функций - это одно название для нескольких функций с разными типами аргументов. Компилятор формирует промежуточные объектные файлы (.o)/(.obj) (в зависимости от комплиятора), в которых указаны имена функций + типы аргументов, поэтому компоновщик видит аргумент функции. Нельзя начинать название функции с подчеркивания:
```
auto Module(double number) // _Z6Moduled (_Z6 - метка функции + кол-во символов, Module - имя функции, d - тип аргумента)
{
    return number > 0 ? number : -number;
}

auto Module(int number) // _Z6Modulei (_Z6 - метка функции + кол-во символов, Module - имя функции, i - сокращенный тип аргумента (int))
{
    return number > 0 ? number : -number;
}
```
